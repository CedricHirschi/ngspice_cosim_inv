{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to this guide for Open Source Mixed Signal Design!","text":"<p>This guide will help you understand the principles of mixed-signal design using open-source tools. We will cover topics such as:</p> <ul> <li>Digital design with SystemVerilog</li> <li>Analog design with SPICE with XSCHEM</li> <li>Cosimulation of digital and analog components with ngspice</li> <li>Visualization of simulation results with XSCHEM and Python</li> </ul> <p>By the end of this guide, you will have a solid understanding of how to create and simulate mixed-signal designs using open-source tools.</p>"},{"location":"cosimulation/bridges/","title":"Bridges","text":""},{"location":"cosimulation/bridges/#what-are-bridges","title":"What are bridges?","text":"<p>Bridges in ngspice define the transitions between the analog and digital domain. There are three different types of bridges:</p> <ul> <li><code>dac_bridge</code>: Digital-to-Analog node bridge, at outputs of digital blocks</li> <li><code>adc_bridge</code>: Analog-to-Digital node bridge, at inputs of digital blocks</li> <li><code>bidi_bridge</code>: Bidirectional bridge, allowing for two-way communication between analog and digital domains</li> </ul> <p>These bridges have a variety of configurable parameters, such as trigger voltage levels, rise/fall times and delays.</p>"},{"location":"cosimulation/bridges/#automatically-placed-bridges","title":"Automatically placed Bridges","text":"<p>By default, ngspice inserts some bridges automatically between analog and digital domains based on the circuit topology. The default bridges are:</p> <ul> <li>Digital-to-Analog: <code>.model auto_dac dac_bridge(out_low = 0 out_high = 'VCC')</code></li> <li>Analog-to-Digital: <code>.model auto_adc adc_bridge(in_low = 'VCC/2' in_high = 'VCC/2')</code></li> <li>Bidirectional: <code>.model auto_bidi bidi_bridge(out_high='VCC' in_low='VCC/2' in_high='VCC/2')</code></li> </ul> <p>But they can be overwritten. I suggest using bidirectional bridges for all of them, since they have the most flexible parameters. You can change the default bridges as follows: <pre><code>.model adc_buff_clk adc_bridge(in_low = 'vdd/2' in_high = 'vdd/2')\n\n.control\n.model adc_buff_clk adc_bridge(in_low='vdd/2' in_high='vdd/2')\n\n.control\npre_set auto_bridge_d_out =\n+ ( \\\".model auto_bridge_out bidi_bridge(direction=0 out_high='vdd' t_rise=0.2n t_fall=0.2n)\\\"\n+   \\\"auto_bridge_out%d [ %s ] [ %s ] null auto_bridge_out\\\" )\npre_set auto_bridge_d_in =\n+ ( \\\".model auto_bridge_in bidi_bridge(direction=1 in_low='vdd/3' in_high='vdd/3*2')\\\"\n+   \\\"auto_bridge_in%d [ %s ] [ %s ] null auto_bridge_in\\\" )\n.endc\n</code></pre> This defines the following models:</p> <ul> <li><code>auto_bridge_out</code>: A bidirectional bridge for analog-to-digital conversion.</li> <li><code>auto_bridge_in</code>: A bidirectional bridge for digital-to-analog conversion.</li> <li><code>adc_buff_clk</code>: A bridge for clock signals in ADCs. If you have a hysteresis on the digital inputs, your signal may be undefined for some duration of the clock edge. Since one may not want this behavior in their clock inputs, we define a bridge model specifically for clock inputs.</li> </ul>"},{"location":"cosimulation/bridges/#manually-placing-bridges","title":"Manually placing Bridges","text":"<p>Bridges can also be placed manually. The components for the bridges are located in the generic library and are called <code>adc_bridge.sym</code> and <code>dac_bridge.sym</code>.</p> <p>We can take our clock buffer above as an example. Place the <code>adc_bridge.sym</code> directly in front of the clock pin of a digital design. Double-click on the bridge and change the model from <code>adc_buff</code> to <code>adc_buff_clk</code>. Now, the clock input should use the properties as described in the <code>adc_buff_clk</code> model. </p>"},{"location":"cosimulation/design/","title":"Creating a Mixed-Signal Simulation","text":"<p>To get a full mixed-signal simulation, we need:</p> <ul> <li>Digital design, we write it in SystemVerilog</li> <li>Analog design, in SPICE, designed in XSCHEM</li> <li>A symbol representing the digital design as a block for XSCHEM</li> <li>Testbench, combining both Analog and Digital designs and defining their interaction</li> </ul> <p>In our example, we create a simple PWM DAC, with digitally adjustable output voltage levels.</p>"},{"location":"cosimulation/design/#digital-design","title":"Digital Design","text":"<p>We create a simple SystemVerilog module with the following signals:</p> <p>Inputs</p> <ul> <li><code>clk_i</code>: Clock signal</li> <li><code>rst_ni</code>: Active-low reset signal</li> <li><code>set_i[3:0]</code>: 4-bit control signal for the duty cycle</li> </ul> <p>Outputs</p> <ul> <li><code>pwm_o</code>: PWM output signal</li> </ul> <p>The module might look something like this: <pre><code>`timescale 1ns/1ps\n\nmodule pwm_dac (\n    input logic       clk_i,  // Clock signal\n    input logic       rst_ni, // Active-low reset signal\n    input logic [3:0] set_i,  // 4-bit control signal for the duty cycle\n\n    output logic      pwm_o   // PWM output signal\n);\n\n    logic [3:0] counter_d, counter_q;\n\n    initial begin\n        $display(\"PWM DAC digital part started\");\n        $dumpfile(\"pwm_dac.vcd\");\n        $dumpvars(0, pwm_dac);\n    end\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n        if (!rst_ni) begin\n            counter_q &lt;= '0;\n        end else begin\n            counter_q &lt;= counter_d;\n        end\n    end\n\n    always_comb begin\n        if (!rst_ni) begin\n            counter_d = '0;\n        end else begin\n            counter_d = counter_q + 1;\n        end\n    end\n\n    assign pwm_o = (counter_q &lt; set_i) ? 1'b1 : 1'b0;\n\nendmodule\n</code></pre> Important: The <code>`timescale</code> directive is crucial for enabling cosimulation.</p> <p>We save this code as <code>pwm_dac.sv</code> and compile it with Icarus Verilog. This is done with the following command: <pre><code>iverilog -g2012 -o pwm_dac pwm_dac.sv\n</code></pre> The <code>-g2012</code> flag tells Icarus Verilog to use the SystemVerilog 2012 standard.</p> <p>This gives us a compiled simulation model that we can use for testing. You can actually open the resulting <code>pwm_dac</code> file with your text editor and see that it's a script for the <code>vvp</code> tool.</p>"},{"location":"cosimulation/design/#analog-design","title":"Analog Design","text":"<p>We design a simple 1-stage RC lowpass filter. We assume the input frequency to be \\(100\\ MHz\\). The resulting output frequency is thus \\(\\frac{100\\ MHz}{16} = 6.25\\ MHz\\). We put the corner frequency of the filter two decades lower, at \\(62.5\\ kHz\\). With \\(R = 100\\ k\\Omega\\), we need \\(C = \\frac{1}{2\\pi f_c R} \\approx 25.5\\ pF\\).</p> <p>We implement the circuit in the testbench <code>pwm_dac_tb.sch</code> directly via <pre><code>xschem pwm_dac_tb.sch\n</code></pre> The resulting circuit looks something like this: </p>"},{"location":"cosimulation/design/#symbol-for-the-digital-design","title":"Symbol for the Digital Design","text":"<p>We need to create a symbol for the digital design that we can use in the testbench. This symbol should represent the inputs and outputs of the <code>pwm_dac</code> module. Create a new symbol with <pre><code>xschem pwm_dac.sym\n</code></pre> Directly after opening, please save the symbol via <code>File -&gt; Save as symbol</code> (or <code>Ctrl + Alt + S</code>). This ensures that the symbol properties are properly setup.</p> <p>Now, we first configure these properties by double-clicking the emtpy canvas. This opens an empty text input where we enter: <pre><code>type=primitive\nformat=\"@name [ @@clk_i @@rst_ni @@set_i[3..0] ] [ @@pwm_o ] @model\"\ntemplate=\"name=A1 model=pwm_dac\"\n</code></pre> This defines:</p> <ul> <li>The type of the symbol (<code>primitive</code>, other options include <code>subcircuit</code> for actual circuits)</li> <li>The format of the circuit. This has to be very specific:<ol> <li><code>@name</code>: The name of the instance in the schematic (e.g., <code>A1</code>)</li> <li><code>[ @@clk_i @@rst_ni @@set_i[3..0] ]</code>: The input ports of the instance</li> <li><code>[ @@pwm_o ]</code>: The output ports of the instance</li> <li><code>@model</code>: The model name of the instance (e.g., <code>pwm_dac</code>)</li> </ol> </li> <li>The template for the instance. This defines how the instance will be instantiated in the schematic. Here, the instance gets the name <code>A1</code> and the model <code>pwm_dac</code>, which we have built above.</li> </ul> <p>Now, we place the pins of the symbol in the schematic. Do this via <code>Symbol -&gt; Place symbol pin</code> (<code>Alt + P</code>). Make sure to set the correct name and direction (<code>in</code>, <code>out</code> or <code>inout</code>) for each pin.</p> <p>Your symbol might look something like this:  The <code>@symname</code> and <code>@name</code> texts are placeholders that will be replaced with the actual symbol and instance names when the schematic is instantiated. You can leave them out.</p>"},{"location":"cosimulation/design/#testbench","title":"Testbench","text":"<p>Now, we go back to the testbench <pre><code>xschem pwm_dac_tb.sch\n</code></pre></p> <p>Place our <code>pwm_dac.sym</code> symbol into the schematic. Now, we need to specify the cosimulation model for the PWM DAC. We can do this in this symbols properties directly. When you open the symbols properties by double-clicking it, you should be able to see the name and model properties. On a new line, add the following: <pre><code>device_model=\".model pwm_dac d_cosim simulation=\\\"ivlng\\\" sim_args=[\\\"../pwm_dac\\\"]\"\n</code></pre> The <code>device_model</code> property specifies the model name and the simulation parameters for the PWM DAC. This tells ngspice to use the <code>ivlng</code> simulation method with the specified arguments.</p> <p>Now we can hook up the output up to the lowpass filter. Also place voltage sources to input the clock and reset signals, as well as the control inputs. Single signals from a bus can be accessed via the <code>a0 up to a3</code> labels if you have a <code>a[3..0]</code> label.</p> <p>The control inputs <code>set_i0 to set_i3</code> are each connected to their own voltage source so that we can simulate a simple changing digital input. A simple example would be the following:</p> <ul> <li><code>set_i0</code>: Constant 1.5V</li> <li><code>set_i1</code>: Constant 1.5V</li> <li><code>set_i2</code>: Step 0V to 1.5V at 15us</li> <li><code>set_i3</code>: Constant 0V</li> </ul> <p>With this, we simulate a simple step from input code 0x03 to 0x07 at 15us, such that we can observe the behavior of the PWM DAC.</p> <p>Add the device models and simulation commands/launcher. For the simulation commands, we use the following: <pre><code>.include pwm_dac_tb.save\n.param temp=27\n.param VCC=1.5\n.control\nsave all\ntran 10n 10u\nwrite pwm_dac_tb.raw\n</code></pre> Here, the important part is <code>VCC</code>. This defines the logic levels for the digital-&gt;analog and analog-&gt;digital bridges. These bridges can be set up more sophisticated (See Bridges), but for now we just set <code>VCC</code> to our vdd, 1.5V. Also, we set the simulation time to 10 microseconds with a timestep of 10 nanoseconds and to save all data to <code>pwm_dac_tb.raw</code>.</p> <p>Also add a waveform loader and two graphs.</p> <p>The testbench might look like this: </p>"},{"location":"cosimulation/design/#simulation","title":"Simulation","text":"<p>Currently, for the simulation to run successfully, some tweaks need to be made when you are using the IIC-OSIC-TOOLS container: <pre><code>sudo mkdir -p /usr/local/lib/ngspice\nsudo cp /foss/tools/ngspice/lib/ngspice/ivlng.vpi /usr/local/lib/ngspice\nsudo cp /foss/tools/iverilog/lib/libvvp.so /foss/tools/ngspice/lib/ngspice\n</code></pre></p> <p>We can then run the simulation with the simulation launcher. You should see such an output: <pre><code>******\n** ngspice-44.2 : Circuit level simulation program\n** Compiled with KLU Direct Linear Solver\n** The U. C. Berkeley CAD Group\n** Copyright 1985-1994, Regents of the University of California.\n** Copyright 2001-2024, The ngspice team.\n** Please get your ngspice manual from https://ngspice.sourceforge.io/docs.html\n** Please file your bug-reports at http://ngspice.sourceforge.net/bugrep.html\n** Creation Date: Tue Jul 29 08:21:22 UTC 2025\n******\n\nNote: No compatibility mode selected!\n\nCircuit: ** sch_path: /workspaces/oscic-playground/cosim/pwm_dac_tb.sch\n\nNote: No compatibility mode selected!\n\nReducing trtol to 1 for xspice 'A' devices\nDoing analysis at TEMP = 27.000000 and TNOM = 27.000000\n\nUsing SPARSE 1.3 as Direct Linear Solver\n\nInitial Transient Solution\n--------------------------\n\nNode                      Voltage\n----                      -------\nout                       0\nunfilt                    0\nclk                       0\nrst                       1.5\nvdd                       1.5\nvss                       0\nset0                      1.5\nset1                      1.5\nset2                      1.5\nset3                      0\nv#branch                  0\nv7#branch                 0\nv6#branch                 0\nv5#branch                 0\nv4#branch                 0\nv3#branch                 0\nv2#branch                 0\nv1#branch                 0\nauto_dac#branch_1_0       0\n\nPWM DAC digital part started\nVCD info: dumpfile pwm_dac.vcd opened for output.\n Reference value 9_95157e-06\nNo. of Data Rows : 205255\nbinary raw file \"pwm_dac_tb.raw\"\nngspice 1 -&gt;\n</code></pre> You can see the <code>PWM DAC digital part started</code> and <code>VCD info: dumpfile pwm_dac.vcd opened for output.</code> which indicate that the digital part of the simulation is running properly!</p>"},{"location":"cosimulation/design/#visualization","title":"Visualization","text":"<p>XSCHEM's built in graphs already include a handy way to display digital and analog signals concurrently. We use one of our graphs for the digital signals and one for the analog signals.</p> <p>In the graph for the analog signals, add the <code>unfilt</code> and <code>out</code> signals. The settings can remain the default.</p> <p>In the graph for the digital signals, add the <code>clk</code>, <code>rst</code> signals as well as <code>set;set3,set2,set1,set0</code>, which allows us to look at the <code>set</code> signals as a bus. Your plots might look like this: </p> <p>We can see that our simple PWM DAC example works as expected.</p> <p>Now, you can also open the .vcd file in a waveform viewer to inspect the digital part more closely.</p>"},{"location":"cosimulation/intro/","title":"Introduction","text":""},{"location":"cosimulation/intro/#how-does-co-simulation-work-in-ngspice","title":"How does co-simulation work in ngspice?","text":"<p>Cosimulation with ngspice enables mixed-signal simulation by combining SPICE-based analog circuit models with a digital HDL simulation engine. In this setup, ngspice runs the analog portion of the design (e.g., transistor-level circuits, passive networks), while the digital portion (e.g., control logic, ADC state machines) is executed by an external HDL simulator. Communication occurs via a well-defined interface - ngspice exchanges signal values with the digital simulator at synchronized timesteps, ensuring that analog and digital events remain time-aligned.</p> <p>When using Icarus Verilog (iverilog and vvp), ngspice interacts through its d_cosim or d_process model, spawning the Icarus Verilog simulation process and passing data through pipes or sockets. Compared to Verilator, which compiles Verilog into a C++ model that must be linked and rebuilt for every change, Icarus Verilog offers faster iteration, direct interpretation of HDL without a compile-link cycle, and better compatibility with ngspice\u2019s cosimulation interface - making it the preferred choice when doing rapid mixed-signal development and debugging.</p>"},{"location":"xschem/creating_design/","title":"Creating a New Design","text":""},{"location":"xschem/creating_design/#creating-a-new-block","title":"Creating a new Block","text":"<p>Here, we will create our own inverter design, including a sub-sheet, symbol and testbench.</p>"},{"location":"xschem/creating_design/#creating-the-schematic","title":"Creating the Schematic","text":"<p>To create a new schematic in XSCHEM, we simply create a new <code>.sch</code> file (schematic format for XSCHEM). We can do this via <pre><code>xschem inverter.sch\n</code></pre> You will get a warning that the file does not exist, which is fine.</p> <p>Now, you should see a blank schematic editor window where you can start building your inverter design.</p> <p>Symbols</p> <p>We start by placing our two MOSFETs (NMOS and PMOS) in the schematic. To do this, select the <code>Insert Symbol</code> symbol from the toolbar (looks like an AND gate) or press <code>Insert</code> on your keyboard.</p> <p>This will open the <code>Choose symbol</code> dialog, where we can see some libraries. In our case, we choose the one ending with <code>ihp-sg13g2/libs.tech/xschem</code>. There, we choose <code>sg23g2_pr</code> and <code>sg13_lv_nmos</code>. Click <code>OK</code> to insert the symbol into the schematic. Place the symbol by moving it somewhere sensible and by then left-clicking to confirm the placement.</p> <p>Repeat this for the PMOS transistor by selecting <code>sg13_lv_pmos</code> from the same library.</p> <p>Wires</p> <p>Now, we connect the gates and the drains of the NMOS and PMOS transistors together to form the inverter structure. You can place a wire by pressing <code>W</code> on your keyboard while you are at your first connection point. If you want to have a corner in your wire, move the cursor to the position of the corner and press <code>W</code> again. This will place the first wire segment. Then, when you are at the second connection point, simply left-click to finalize the wire placement.</p> <p>Also place some short wires out of the sources and bodies of the transistors as well as some input and output wires out of the gates/drains. Your design should look something like this: </p> <p>Labels</p> <p>Now, let's place some labels to identify each net. To do this, open the <code>Choose symbol</code> dialog by pressing <code>Insert</code> again and go to the builtin devices library. You can do this by pressing the <code>Home</code> button on the bottom left. This will choose the <code>xschem_library/devices</code> library. These are the spice primitives (not physical devices).</p> <p>We want to search for the <code>lab</code> symbols. You can do this by clicking into the search field on the bottom left and by entering <code>lab</code>. This will give us some different options, but we are taking the <code>lab_pin.sym</code> symbol. Select it and place it on the end of the input wire.</p> <p>To copy a symbol instance, select the label and press <code>C</code>. This will attach a new instance to the cursor. You can rotate the current instance by pressing <code>Ctrl + R</code>.</p> <p>Repeat this for the output wire and sources/bodies wires of the transistors.</p> <p>To rename a label, simply double-click on it and enter the new name (<code>lab</code> parameter). Name the labels:</p> <ul> <li>Input: <code>in</code></li> <li>Output: <code>out</code></li> <li>NMOS source/body: <code>VSS</code></li> <li>PMOS source/body: <code>VDD</code></li> </ul> <p>Pins</p> <p>Since we want the inverter to be a symbol in the end, we need to place to place the pins of the symbol. To do this, we use <code>ipin.sym</code> for inputs, <code>opin.sym</code> for outputs and <code>iopin.sym</code> for bidirectional pins from the generic library.</p> <p>Place the following pins:</p> <ul> <li>Input: <code>ipin.sym</code>, name it <code>in</code></li> <li>Output: <code>opin.sym</code>, name it <code>out</code></li> <li>VSS: <code>iopin.sym</code>, name it <code>VSS</code></li> <li>VDD: <code>iopin.sym</code>, name it <code>VDD</code></li> </ul> <p>These pins will attach to the nets of the same name, so we dont need to connect them further.</p> <p>Your schematic should something look like this: </p>"},{"location":"xschem/creating_design/#creating-the-symbol","title":"Creating the Symbol","text":"<p>Now, we want to create a symbol for our inverter.</p> <p>For this, navigate to the <code>Symbol</code> menu in the toolbar and click on <code>Make symbol from schematic</code>. This will create a <code>inverter.sym</code> file in the same directory as <code>inverter.sch</code>.</p> <p>Open the symbol using <pre><code>xschem inverter.sym\n</code></pre></p> <p>You should see the default generated symbol for the inverter. </p> <p>This is good but it looks quite boring. You can improve it by editing the symbol by moving/rotating the pins around and by adding new polygons (<code>P</code>), generally using the tools in the toolbar.</p> <p>An improved version could look like this: </p>"},{"location":"xschem/creating_design/#creating-the-testbench","title":"Creating the Testbench","text":"<p>Now, we create a testbench for our inverter.</p> <p>For this, create the testbench schematic: <pre><code>xschem inverter_tb.sch\n</code></pre></p>"},{"location":"xschem/creating_design/#placing-our-new-block","title":"Placing our new Block","text":"<p>Place your inverter symbol by going to the current directory via the <code>Current Dir</code> button of the <code>Choose symbol</code> dialog (<code>Insert</code>) and selecting the <code>inverter.sym</code> file.</p>"},{"location":"xschem/creating_design/#placing-the-testbench-components","title":"Placing the Testbench Components","text":"<p>Now, we need to connect the input and output of the inverter to the testbench. Specifically, we add:</p> <ul> <li>Input: Rectangle voltage source</li> <li>VSS/VDD: DC supply voltages</li> <li>Output: Some loading resistor</li> </ul> <p>Place three voltage sources <code>vsource</code> from the generic library.</p> <p>Place one resistor <code>res</code> from the generic library.</p> <p>Place grounds (<code>gnd</code>) at the lower terminals of each voltage source and the resistor.</p> <p>Connect the voltages and resistor accordingly using wires (<code>W</code>). I suggest using labels for clarity.</p> <p>Set the voltages for the voltage sources:</p> <ul> <li>VSS: <code>0</code></li> <li>VDD: <code>1.5</code></li> <li>Input: <code>\"pulse(0 1.5 1n 0.1n 0.1n 1n 2n)\"</code> (Dont forget the quotes)  This generates a pulse waveform from 0 to 1.5V, with a delay for the first edge of 1 ns, 0.1ns fall and rise times, 1 ns high time and 2 ns period.</li> </ul> <p>Set the resistance to <code>1Meg</code>.</p>"},{"location":"xschem/creating_design/#setting-up-the-simulation-commands","title":"Setting up the Simulation Commands","text":"<p>Now, we need to write the commands for actually running the simulation. We will just take them from the XSCHEM PDK starting site. In a new terminal, open XSCHEM via <code>xschem</code>. From the PDK start page, select (select multiple via holding <code>Shift</code>):</p> <ul> <li>\"Load IHP SG13G2 spice models for ngspice\" (<code>Libs_Ngspice</code>)</li> <li>\"Simulation skeleton for ngspice\" (<code>SimulatorNGSPICE</code>)</li> <li>\"Create .save file, create netlist, simulate with ngspice\" (<code>SimulateNGSPICE</code>)</li> </ul> <p>Copy these blocks via <code>Ctrl+C</code> and paste them into your testbench schematic via <code>Ctrl+V</code>.</p> <p>At the moment, this simulates the operating point only. We need to modify the <code>SimulatorNGSPICE</code> code block, specifically, we need to change the <code>op</code> command to (to also save all voltages/currents): <pre><code>save all\ntran 50p 10n\n</code></pre> While you are in the code block, also change all <code>&lt;filename&gt;</code> instances to <code>inverter_tb</code>.</p>"},{"location":"xschem/creating_design/#adding-graphs","title":"Adding Graphs","text":"<p>We also want a graph, which can be placed via <code>Simulation -&gt; Graphs -&gt; Add waveform graph</code>. Also, add a waveform reload launcher via <code>Simulation -&gt; Graphs -&gt; Add waveform reload launcher</code>.</p> <p>Your testbench should look something like this: </p>"},{"location":"xschem/creating_design/#running-the-testbench","title":"Running the testbench","text":"<p>Now, run the testbench via <code>Ctrl + left click</code> on the <code>SimulateNGSPICE</code> launcher. Then, load the waves via the <code>load waves</code> launcher.</p> <p>Now, we want to add some traces to the graph. You can do this by double-clicking in the middle of the graph. You should be able to see a list of traces to plot on the left side. There, find and add the <code>in</code> and <code>out</code> traces by double-clicking on them.</p> <p>By default, all traces are the same color. To changes that, click on the <code>AUTO SET</code> button on the bottom right.</p> <p>Now, click <code>Apply</code> and <code>OK</code>. You should see some traces in the graph, but you need to adjust the time scale to see the pulses clearly. You can do this by holding <code>Shift</code> and scrolling the mouse wheel to zoom in and out, or by holding <code>Ctrl</code> and scrolling to pan.</p> <p>Your plot may look something like this: </p>"},{"location":"xschem/pdk_examples/","title":"PDK Examples","text":""},{"location":"xschem/pdk_examples/#exploring-the-pdk-examples","title":"Exploring the PDK Examples","text":"<p>The PDK (Process Design Kit) examples provide a set of pre-configured designs and simulations that can be used as a starting point for your own projects. These examples cover a wide range of use cases and demonstrate best practices for using the tools and libraries available in the PDK.</p> <p>To explore them, simply open XSCHEM: <pre><code>xschem\n</code></pre></p> <p>You should see this start page:  Here, you can see some useful commands and blocks which you can place into your own designs to the right. On the top right, you can access a cheatsheet of the controls available in XSCHEM.</p> <p>We are interested in the examples to the left, those for ngspice to be exact. Jump into this sub-sheet by pressing <code>E</code> while hovering over the green rectangle (<code>IHP_testcases</code>) below <code>NGSPICE</code>.</p> <p>You should see this sheet:  Here, you can explore various test cases and examples for different analysis types. You can once again enter each test case by pressing <code>E</code> while hovering over it. Leave a sub-sheet by pressing <code>Ctrl + E</code>.</p>"},{"location":"xschem/pdk_examples/#simulating-a-test-case---inverter","title":"Simulating a Test Case - Inverter","text":"<p>We explore the <code>tran_logic_not</code> test case. This simulates a logic inverter using a transient analysis. Please enter it. You should see this sheet: </p> <p>Let's just simulate the inverter first.</p> <p>In order to do a simulation, we first need to generate the netlist. The netlist describes the device instances and their connections in the circuit. In XSCHEM, you can generate the netlist by clicking on the \"Netlist\" button in the toolbar.</p> <p>After the netlist is generated, you can run the simulation by clicking on the \"Simulate\" button in the toolbar. This will open a new window, which is the interactive prompt for ngspice.</p> <p>Simulation Log</p> <p>You should see this log output: <pre><code>*************\n** ngspice-44.2 Circuit level simulation program\n** Compiled with KLU Direct Linear Solver\n** The U. C. Berkeley CAD Group\n** Copyright 1985-1994, Regents of the University of California.\n** Copyright 2001-2024, The ngspice team.\n** Please get your ngspice manual from https://ngspice.sourceforge.io/docs.html\n** Please file your bug-reports at http://ngspice.sourceforge.net/bugrep.html\n** Creation Date: Tue Jul 29 08:21:22 UTC 2025\n********\n\nNote: No compatibility mode selected!\n\nCircuit: ** sch_path: /foss/pdks/ihp-sg1392/libs.tech/xschem/s91392_tests/tran_logic_not.sch\n\nDoing analysis at TEMP = 27.000000 and TNOM = 27.000000\n\nUsing SPARSE 1.3 as Direct Linear Solver\n\nInitial Transient Solution\n--------------------------\n\nNode                                   Voltage\n----                                   -------\nin                                           0\nnet1                                       1.2\nout                                        1.2\nvdd#branch                        -2.67579e-10\nvin#branch                         4.03724e-11\n\n Reference value: 1.21150e-08\nNo. of Data Rows : 465\ntdelay              = 1.119817e-10 targ= 2.236982e-09 trig= 2.125000e-09\nbinary raw file \"tran_logic_not.raw\"\nngspice 1 -&gt;\n</code></pre> This output shows that the simulation was successful and provides information about the circuit being simulated.</p> <p>This includes:</p> <ul> <li>The temperature at which the simulation was run</li> <li>The initial transient solution (values at each node at time t=0)</li> <li>The amount of data generated during the simulation (<code>No. of Data Rows</code>)</li> <li>Measurement results (e.g., propagation delay <code>tdelay</code>, user-defined by <code>.meas</code> commands)</li> <li>The location of the binary raw file containing the simulation data (<code>tran_logic_not.raw</code>)</li> </ul> <p>Graphs</p> <p>The simulation results in the resulting raw file can also be plotted. You can do this by using the waveform reload launcher (<code>load waves Ctrl + left click</code>).</p> <p>This should load the traces into the plot in the schematic editor. It should look something like this: </p> <p>We can see that the inverter is functioning as expected, with the output being the inverse of the input.</p> <p>Measurements/Analysis</p> <p>You can already do some analysis in ngspice directly via <code>.meas</code> commands. In the case of this simulation, we have this command: <pre><code>meas tran tdelay TRIG v(in) VAl=0.9 FALl=1 TARG v(out) VAl=0.9 RISE=1\n</code></pre> This measurement command measures the propagation delay (<code>tdelay</code>) of the inverter by triggering on the input voltage (<code>v(in)</code> at 0.9V falling edge) and targeting the output voltage (<code>v(out)</code> at 0.9V rising edge). From the log output, we can see that the measured propagation delay is 0.112 ns, where we triggered at the falling input edge at 2.125 ns and registered the output rising edge at 2.237 ns.</p> <p>Later, we take a look on how to look at this raw data and perform more in-depth analysis on it in Python.</p>"},{"location":"xschem/pdk_examples/#modifying-component-parameters","title":"Modifying component parameters","text":"<p>Staying inside this test case, we now want to see how the behaviour of the inverter changes depending on the transistor sizing. We can do this by modifying the width and length of the transistors in the inverter circuit.</p> <p>In XSCHEM, you can easily modify component parameters by selecting the component (double click on component) and editing its properties in the property editor. For example, to change the width of a transistor, you can change the <code>w</code> parameter.</p> <p>After making changes to the transistor sizes, you can regenerate the netlist and run the simulation again to see how the changes affect the inverter's performance.</p>"},{"location":"xschem/pdk_examples/#modifying-simulation-parameters","title":"Modifying simulation parameters","text":"<p>To define the behaviour of the simulation, each top-level sheet should include simulation commands. They are placed in a code block like this (double click on it to edit): <pre><code>name=NGSPICE only_toplevel=true\nvalue=\"\n.param temp=27\n.control\nsave all \ntran 50p 20n\nmeas tran tdelay TRIG v(in) VAl=0.9 FALl=1 TARG v(out) VAl=0.9 RISE=1\nwrite tran_logic_not.raw\n.endc\n\"\n</code></pre> Here, <code>name</code> simply specifies the title used for the code block, <code>only_toplevel</code> indicates that the commands should only be applied to the top-level sheet, and <code>value</code> contains the actual simulation commands to be executed. Let's take a closer look at the commands used in this example. <pre><code>.param temp=27\n.control\nsave all\ntran 50p 20n\nmeas tran tdelay TRIG v(in) VAl=0.9 FALl=1 TARG v(out) VAl=0.9 RISE=1\nwrite tran_logic_not.raw\n.endc\n</code></pre></p> <ul> <li>The <code>.param</code> command sets a simulation parameter (in this case, temperature).</li> <li>The <code>.control</code> block contains the simulation commands to be executed (Note: There are multiple ways to do this. We will just focus on this one for now).</li> <li>The <code>save all</code> command tells the simulator to save all node voltages and branch currents.</li> <li>The <code>tran 50p 20n</code> command performs a transient analysis with a maximum time step of 50 ps and a total simulation time of 20 ns.</li> <li>The <code>meas</code> command measures the propagation delay of the inverter (as described above).</li> <li>The <code>write</code> command saves the simulation results to a raw file.</li> <li>The <code>.endc</code> command ends the control (<code>.control</code>) block.</li> </ul> <p>Now, if we want to modify the simulation parameters, we can do so by editing the code block accordingly. For example, we could change the temperature or the transient analysis time settings: <pre><code>.param temp=10\n.control\nsave all\ntran 50p 10n\nmeas tran tdelay TRIG v(in) VAl=0.9 FALl=1 TARG v(out) VAl=0.9 RISE=1\nwrite tran_logic_not.raw\n.endc\n</code></pre> Here, we simulate the inverter at 10 degrees Celsius with a total simulation time of 10 ns.</p>"},{"location":"xschem/python/","title":"Analysis in Python","text":"<p>Sometimes, doing analysis of the simulation results can be cumbersome. To facilitate this, we can use Python scripts to process the raw data files generated by the simulations. This allows us to automate the analysis and generate plots or reports more easily.</p>"},{"location":"xschem/python/#reading-raw-files","title":"Reading <code>.raw</code> files","text":"<p>For reading in <code>.raw</code> files, multiple libraries exist. For me, it was easiest to use my own file parser: <pre><code>class NGSpiceRaw:\n    def __init__(self, fname: str, live: bool = True):\n        \"\"\"\n        Initialize the NGSpiceRaw object.\n\n        Args:\n            fname (str): The name of the .raw file to read.\n            live (bool): Whether to reload the file on each access.\n        \"\"\"\n        self.fname = fname\n        self.live = live\n\n        self._reload()\n\n    def _reload(self):\n        self.arrs, self.plots = self._read_raw(self.fname)\n        self.plot, self.arr = self.plots[-1], self.arrs[-1]\n        print(f\"Loaded {len(self.plots)} plots from {self.fname}\")\n\n    def _read_raw(self, fname: str):\n        \"\"\"\n        Read a binary ngspice .raw file.\n\n        Returns:\n          arrs  : list of numpy structured arrays, one per plot\n          plots : list of metadata dicts, parallel to arrs\n        \"\"\"\n        with open(fname, 'rb') as fp:\n            arrs = []\n            plots = []\n            plot = {}\n            while True:\n                line = fp.readline(BSIZE_SP)\n                if not line:\n                    break\n                parts = line.split(b':', 1)\n                if len(parts) != 2:\n                    continue\n                key, val = parts[0].lower(), parts[1].strip()\n                if key in MDATA_LIST:\n                    plot[key] = val\n                if key == b'variables':\n                    nvars   = int(plot[b'no. variables'])\n                    npoints = int(plot[b'no. points'])\n                    plot['varnames'] = []\n                    plot['varunits'] = []\n                    for _ in range(nvars):\n                        ascii_line = fp.readline(BSIZE_SP).decode('ascii')\n                        idx, name, *unit = ascii_line.split()\n                        plot['varnames'].append(name)\n                        plot['varunits'].append(unit[0])\n                if key == b'binary':\n                    # build dtype (complex if flagged, else float)\n                    fmt = np.complex_ if b'complex' in plot[b'flags'] else float\n                    row_dtype = np.dtype({\n                        'names':   plot['varnames'],\n                        'formats': [fmt]*len(plot['varnames'])\n                    })\n                    # read data block\n                    data = np.fromfile(fp, dtype=row_dtype, count=npoints)\n                    arrs.append(data)\n                    plots.append(plot.copy())\n                    plot.clear()\n                    fp.readline()\n\n        return arrs, plots\n\n    def select(self, idx: int):\n        \"\"\"\n        Select a plot by index.\n        \"\"\"\n        if idx &lt; -len(self.plots) or idx &gt;= len(self.plots):\n            raise IndexError(\"Index out of range\")\n\n        self.plot = self.plots[idx]\n        self.arr = self.arrs[idx]\n\n        return self.plot, self.arr\n\n    @property\n    def names(self):\n        return self.arr.dtype.names\n\n    def __getitem__(self, key):\n        \"\"\"\n        Get a variable by name or index.\n        \"\"\"\n        if self.live:\n            self._reload()\n\n        if key in self.names:\n            return self.arr[key]\n        else:\n            raise KeyError(f\"Variable '{key}' not found\")\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Set a variable by name or index.\n        \"\"\"\n        if self.live:\n            self._reload()\n\n        if key in self.names:\n            raise KeyError(f\"Variable '{key}' already exists\")\n        else:\n            # Add new variable to the array\n            new_dtype = np.dtype(self.arr.dtype.descr + [(key, value.dtype)])\n            new_arr = np.zeros(self.arr.shape, dtype=new_dtype)\n            for name in self.names:\n                new_arr[name] = self.arr[name]\n            new_arr[key] = value\n            self.arr = new_arr\n            self.arrs[-1] = new_arr\n            self.plot['varnames'].append(key)\n            self.plot['varunits'].append('')\n            self.plot[b'no. variables'] = str(len(self.plot['varnames']))\n            self.plot[b'no. points'] = str(len(self.arr))\n</code></pre></p> <p>This parser is quite easy to use: <pre><code>data = NGSpiceRaw(\"../simulations/dc_lv_nmos.raw\", live=False)\nprint(\"Fields:\", data.names)\n\nv_ds = data[\"v(v-sweep)\"]\ni_vd = data[\"i(vd)\"]\nv_th = data[\"v(@n.xm1.nsg13_lv_nmos[vth])\"]\ngm = data[\"@n.xm1.nsg13_lv_nmos[gm]\"]\ngds = data[\"@n.xm1.nsg13_lv_nmos[gds]\"]\ncgs = data[\"@n.xm1.nsg13_lv_nmos[cgsol]\"]\ncgd = data[\"@n.xm1.nsg13_lv_nmos[cgdol]\"]\n</code></pre></p>"},{"location":"xschem/python/#sweeps","title":"Sweeps","text":"<p>I did not yet find out how to properly extract sweeps from the data. Here is the hacky workaround I have used: <pre><code>class Sweep:\n    def __init__(self):\n        self.values = np.array([])\n\n    def linear(self, start: float, stop: float, step: float):\n        self.values = np.arange(start, stop + step, step)\n\n        return self\n\n    def split(self, data: np.ndarray):\n        if len(data) % len(self.values) != 0:\n            raise ValueError(\"Data length is not divisible by n\")\n        return np.array(np.array_split(data, len(self.values)))\n\n    def __getitem__(self, index: int):\n        if index &lt; 0 or index &gt;= len(self.values):\n            raise IndexError(\"Index out of range\")\n        return self.values[index]\n</code></pre> Which can be used like <pre><code>vgs_sweep = Sweep().linear(0.0, 1.0, 0.1)\n\nv_ds = vgs_sweep.split(v_ds)[0] # This will be the same every time since it's the second sweep parameter\ni_vd = vgs_sweep.split(i_vd)\nv_th = vgs_sweep.split(v_th)\ngm = vgs_sweep.split(gm)\ngds = vgs_sweep.split(gds)\ncgs = vgs_sweep.split(cgs)\ncgd = vgs_sweep.split(cgd)\n</code></pre></p>"},{"location":"xschem/python/#plotting","title":"Plotting","text":"<p>To plot the resulting drain current of this sweep of a MOSFET, you would then do: <pre><code>plt.figure(figsize=(10, 6))\n\nfor i, (vgs, values_split) in enumerate(zip(vgs_sweep.values, i_vd)):\n    plt.plot(v_ds, values_split, label=f\"$V_{{gs}} = {vgs:.1f}\\\\ V$\", linewidth=1.5)\n\nplt.xlabel(\"$V_{ds}$ [V]\")\nplt.ylabel(\"$I_{d} [A]$\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre></p> <p>Which results in the following plot: </p>"}]}